import os.path
import mock

from exploitdb.exploit_fetcher import _create_dirs, fetch_exploits


class TestExploitFetcher(object):
    def test_create_dirs(self, fetcher_parser_mock):
        assert os.path.exists(
            fetcher_parser_mock.get('separator', 'comment_dir')) is False
        assert os.path.exists(
            fetcher_parser_mock.get('separator', 'code_dir')) is False
        assert os.path.exists(
            fetcher_parser_mock.get('separator', 'quarantine_dir')) \
            is False
        _create_dirs(fetcher_parser_mock)
        assert os.path.exists(
            fetcher_parser_mock.get('separator', 'comment_dir')) is True
        assert os.path.exists(
            fetcher_parser_mock.get('separator', 'code_dir')) is True
        assert os.path.exists(
            fetcher_parser_mock.get('separator', 'quarantine_dir')) \
            is True

    @mock.patch('exploitdb.exploit_fetcher.os.path.exists')
    def test_fetch_exploits(self, exists_mock, fetcher_parser_mock,
                            db_instance, repo_mock):
        # first test: exploit db is fetched the first time
        exists_mock.return_value = False
        fetched_exploits = fetch_exploits(fetcher_parser_mock, db_instance)

        assert fetched_exploits is None
        assert repo_mock.clone_from.call_count == 1
        repo_mock.clone_from.assert_called_with(
            fetcher_parser_mock.get('git', 'remote_git'),
            fetcher_parser_mock.get('git', 'local_git'))
        result = list(
            db_instance.collection.find({'file': 'exploit_fetcher.py'}))
        result[0].pop(u'_id')
        assert result == [
                {
                    u'id': 1,
                    u'file': u'exploit_fetcher.py',
                    u'description': u'Test Exploit',
                    u'date': u'2019-02-22',
                    u'author': u'Foo Bar',
                    u'type': u'dos',
                    u'platform': u'windows',
                    u'port': 80
                }
            ]
        # second test: exploit db was already fetched
        exists_mock.return_value = True
        fetched_exploits = fetch_exploits(fetcher_parser_mock, db_instance)

        repo_mock.assert_called_with(
            fetcher_parser_mock.get('git', 'local_git'))
        # remotes.origin.fetch() is mocked here
        assert repo_mock.return_value.remotes.origin.fetch.call_count == 1
        result = list(
            db_instance.collection.find({'file': 'new_exploit_fetcher.py'}))
        result[0].pop(u'_id')
        assert result == [
                {
                    u'id': 2,
                    u'file': u'new_exploit_fetcher.py',
                    u'description': u'Exploit Test',
                    u'date': u'2019-02-22',
                    u'author': u'Bar Foo',
                    u'type': u'remote',
                    u'platform': u'linux',
                    u'port': None,
                    u'ip': ['2.2.2.2']
                }
            ]
        assert repo_mock.return_value.remotes.origin.pull.call_count == 1
