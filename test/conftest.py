import pytest
import mock
import os.path

from configparser import ConfigParser

from exploitdb.exploit_separator import Separator
from exploitdb.exploit_analyzer import CommentAnalyzer, CodeAnalyzer
from database.db_interface import MongoDBConnection
from misp.misp_integrator import MISPIntegrator

"""
General fixtures
"""


# doesn't matter if config_main_parser_mock_separator or
# config_main_parser_mock_analyzer is used
@pytest.fixture
def exploit_test_dir(config_main_parser_mock_separator):
    return config_main_parser_mock_separator().get('git', 'local_git')


"""
Exploit fetcher fixtures
"""


@pytest.fixture
def fetcher_parser_mock(tmp_path_factory):
    path = str(tmp_path_factory.mktemp('fetcher_test'))
    comment_dir = os.path.join(path, 'comment_dir')
    code_dir = os.path.join(path, 'code_dir')
    quarantine_dir = os.path.join(path, 'quarantine_dir')
    plot_dir = os.path.join(path, 'plot_dir')
    fetcher_parser_mock = mock.Mock()
    fetcher_parser_mock.get.side_effect = lambda key, value: {
            (
                'separator',
                'comment_dir'
            ): comment_dir,
            (
                'separator',
                'code_dir'
            ): code_dir,
            (
                'separator',
                'quarantine_dir'
            ): quarantine_dir,
            (
                'git',
                'local_git'
            ): 'test/data/exploitdb',
            (
                'git',
                'remote_git'
            ): 'https://github.com/offensive-security/exploitdb.git',
            (
                'git',
                'exploits_csv_file'
            ): 'files_exploits.csv',
            (
                'visualization',
                'plot_dir'
            ): plot_dir
    }[key, value]
    return fetcher_parser_mock


@pytest.fixture
def repo_mock():
    with mock.patch('exploitdb.exploit_fetcher.Repo') as repo_mock:
        fetch_mock = mock.Mock()
        diff_mock = mock.Mock(
            a_rawpath='files_exploits.csv',
            a_blob=mock.Mock(
                data_stream=mock.Mock(
                    read=mock.Mock(
                        return_value=mock.Mock(
                            split=mock.Mock(
                                return_value=[
                                    '2,new_exploit_fetcher.py,Exploit Test,'
                                    '2019-02-22,Bar Foo,remote,linux,']))))),
            b_blob=mock.Mock(
                data_stream=mock.Mock(
                    read=mock.Mock(
                        return_value=mock.Mock(
                            split=mock.Mock(
                                return_value=['']))))))
        fetch_mock.commit.diff.return_value = [diff_mock]
        repo_mock.return_value.remotes.origin.fetch.return_value = [fetch_mock]
        yield repo_mock


"""
Separator fixtures
"""


@pytest.fixture
def config_main_parser_mock_separator():
    with mock.patch('exploitdb.exploit_separator.get_main_config_parser') \
            as config_main_parser_mock_separator:
        parser = ConfigParser()
        parser.read('conf/test_config.cfg')
        config_main_parser_mock_separator.return_value = parser
        yield config_main_parser_mock_separator


@pytest.fixture
def python_separator(config_main_parser_mock_separator):
    return Separator.create_separator('python', mock.Mock())


@pytest.fixture
def separator_comment_dir(config_main_parser_mock_separator):
    return config_main_parser_mock_separator().get('separator', 'comment_dir')


@pytest.fixture
def separator_code_dir(config_main_parser_mock_separator):
    return config_main_parser_mock_separator().get('separator', 'code_dir')


@pytest.fixture
def separator_quarantine_dir(config_main_parser_mock_separator):
    return config_main_parser_mock_separator().get(
        'separator', 'quarantine_dir')


@pytest.fixture
def separator_filenames(config_main_parser_mock_separator):
    filenames = {}
    filenames['read'] = config_main_parser_mock_separator().get(
        'python-test-files', 'read')
    filenames['write'] = config_main_parser_mock_separator().get(
        'python-test-files', 'write')
    filenames['sep_succ'] = config_main_parser_mock_separator().get(
        'python-test-files', 'sep_succ')
    filenames['sep_indent_err'] = config_main_parser_mock_separator().get(
        'python-test-files', 'sep_indent_err')
    return filenames


"""
CommentAnalyzer/CodeAnalyzer fixtures
"""


@pytest.fixture
def config_main_parser_mock_analyzer():
    with mock.patch('exploitdb.exploit_analyzer.get_main_config_parser') \
            as config_main_parser_mock_analyzer:
        parser = ConfigParser()
        parser.read('conf/test_config.cfg')
        config_main_parser_mock_analyzer.return_value = parser
        yield config_main_parser_mock_analyzer


@pytest.fixture
def comment_analyzer_filenames(config_main_parser_mock_analyzer):
    filenames = []
    filenames.append(config_main_parser_mock_analyzer().get(
        'python-test-files', 'comment_analyze'))
    return filenames


@pytest.fixture
def comment_analyzer(comment_analyzer_filenames,
                     config_main_parser_mock_analyzer):
    ca = CommentAnalyzer()
    for filename in comment_analyzer_filenames:
        ca.result.setdefault(filename, {})
    return ca


@pytest.fixture
def comment_analyzer_merge_result(
        comment_analyzer, comment_analyzer_filenames):
    for filename in comment_analyzer_filenames:
        comment_analyzer.result[filename] = {
                'e-mail': ['foo@bar.de'],
                'email': ['bar@foo.de']
            }
    return comment_analyzer


@pytest.fixture
def code_analyzer_filenames(config_main_parser_mock_analyzer):
    filenames = []
    filenames.append(config_main_parser_mock_analyzer().get(
        'python-test-files', 'code_analyze'))
    return filenames


@pytest.fixture
def code_analyzer(code_analyzer_filenames, config_main_parser_mock_analyzer):
    cda = CodeAnalyzer()
    for filename in code_analyzer_filenames:
        cda.result.setdefault(filename, {})
    return cda


"""
MISP fixtures
"""


@pytest.fixture
def config_main_parser_mock_misp():
    with mock.patch('misp.misp_integrator.get_main_config_parser') \
            as config_main_parser_mock_misp:
        parser = ConfigParser()
        parser.read('conf/test_config.cfg')
        config_main_parser_mock_misp.return_value = parser
        yield config_main_parser_mock_misp


@pytest.fixture
def config_misp_parser_mock_misp():
    with mock.patch('misp.misp_integrator.get_misp_config_parser') \
            as config_misp_parser_mock_misp:
        parser = ConfigParser()
        parser.read('conf/misp_attributes.cfg')
        config_misp_parser_mock_misp.return_value = parser
        yield config_misp_parser_mock_misp


@pytest.fixture
def misp_filenames(config_main_parser_mock_misp):
    filenames = []
    filenames.append(config_main_parser_mock_misp().get(
        'python-test-files', 'misp_poc'))
    return filenames


@pytest.fixture()
def misp_mock(config_main_parser_mock_misp):
    with mock.patch('misp.misp_integrator.PyMISP') as misp_mock:
        tag_name, tag_colour = config_main_parser_mock_misp().get(
            'misp', 'tag').split(',')
        taxonomies = config_main_parser_mock_misp().get(
            'misp', 'taxonomies').split(',')
        misp_mock.return_value.get_tags_list.return_value = [
            {
                'name': tag_name,
                'id': 1
            },
            {
                'name': taxonomies[1],
                'id': 4
            },
            {
                'name': taxonomies[2],
                'id': 5
            },
            {
                'name': taxonomies[3],
                'id': 6
            },
            {
                'name': taxonomies[4],
                'id': 7
            }
        ]
        misp_mock.return_value.get_taxonomies_list.return_value = {
            'response':
            [
                {
                    'Taxonomy': {
                        'namespace': taxonomies[1].split(':')[0],
                        'enabled': True,
                        'id': 4
                    }
                },
                {
                    'Taxonomy': {
                        'namespace': taxonomies[2].split(':')[0],
                        'enabled': True,
                        'id': 5
                    }
                },
                {
                    'Taxonomy': {
                        'namespace': taxonomies[3].split(':')[0],
                        'enabled': False,
                        'id': 6
                    }
                }
            ]
        }
        misp_mock.return_value.new_event.return_value = {
            'Event':
            {
                'uuid': '0b15844f-4d04-4ba3-b290-55f693b7b87c'
            }
        }
        # add return values of tag method depending on passed parameters
        succ_tag_response = {
            'message': 'successfully attached to'
        }
        err_tag_response = {
            'message': 'error while attaching'
        }
        misp_mock.return_value.tag.side_effect = lambda uuid, tag_id: {
            (
                '0b15844f-4d04-4ba3-b290-55f693b7b87c',
                1
            ): succ_tag_response,
            (
                '0b15844f-4d04-4ba3-b290-55f693b7b87c',
                4
            ): succ_tag_response}.get((uuid, tag_id), err_tag_response)

        # add return values of search method depending on passed parameters
        succ_attr_response = {
            'response': {
                'Attribute': ['something']
            }
        }
        err_attr_response = {
            'response': {
                'Attribute': []
            }
        }
        misp_mock.return_value.search.side_effect = \
            lambda uuid, type_attribute, category, values, controller: {
                (
                    '0b15844f-4d04-4ba3-b290-55f693b7b87c',
                    'port',
                    'External analysis',
                    8080,
                    'attributes'
                ): succ_attr_response}.get(
                    (uuid, type_attribute, category, values[0], controller),
                    err_attr_response)

        yield misp_mock


@pytest.fixture
def generic_object_generator_mock():
    with mock.patch('misp.misp_integrator.GenericObjectGenerator') \
            as generic_object_generator_mock:
        generic_object_generator_mock.return_value.template_uuid = \
            '3bc7ebe7-9bea-41e2-896a-fe4099279493'
        yield generic_object_generator_mock


@pytest.fixture
def misp_integrator(misp_mock, db_instance, config_main_parser_mock_misp,
                    config_misp_parser_mock_misp):
    return MISPIntegrator(mock.Mock(), db_instance)


"""
Utils fixtures
"""


@pytest.fixture
def results():
    return {
        'exploit.py': {
            'id': 1,
            'cve': [
                'cve-1234-5678'
            ],
            'ip': [
                '1.1.1.1'
            ]
        }
    }, {
        'exploit.py': {
            'id': 2,
            'cve': [
                'cve-9876-5432'
            ],
            'ip': [
                '2.2.2.2'
            ]
        }
    }


@pytest.fixture
def email_results():
    return {
        'exploit.py': {
            'additional_emails': ['foo@bar.de',
                                  'bar@foo.de',
                                  'foobar@barfoo.de'
                                  ],
            'email': ['foo@bar.de',
                      'bar@foo.de'
                      ]
        }
    }


@pytest.fixture
def url_results():
    return {
        'exploit.py': {
            'additional_urls': [
                'www.foo.bar',
                'www.bar.foo',
                'http://www.foobar.barfoo'
            ],
            'software link': [
                'www.foo.bar'
            ],
            'vendor homepage': [
                'www.bar.foo'
            ]
        }
    }


"""
Databse fixtures
"""


@pytest.fixture
def config_main_parser_mock_database():
    with mock.patch('database.db_interface.get_main_config_parser') \
            as config_main_parser_mock_database:
        parser = ConfigParser()
        parser.read('conf/test_config.cfg')
        config_main_parser_mock_database.return_value = parser
        yield config_main_parser_mock_database


@pytest.fixture
def db_instance(config_main_parser_mock_database):
    db = MongoDBConnection(mock.Mock(), db_name='testdb', collection='test')
    db.collection.insert_many([
        {
            'id': 1,
            'file': 'file1.c',
            'date': '2019-10-01',
            'ip': ['1.1.1.1']
        },
        {
            'id': 2,
            'file': 'file2.py',
            'date': '2019-10-02',
            'ip': ['2.2.2.2']
        }
    ])
    yield db
    db.collection.drop()
    db.close()
