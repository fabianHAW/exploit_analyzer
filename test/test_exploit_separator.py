import os.path
import pytest


class TestPythonSeparator(object):
    def test_read_file(self, python_separator, config_parser_mock,
                       separator_exploit_dir):
        exploit = os.path.join(
            separator_exploit_dir,
            config_parser_mock().get('python-test-files', 'read'))
        exploit_read_func = python_separator.read_file(exploit)
        with open(exploit) as f:
            exploit_read_man = f.read()
        assert exploit_read_func == exploit_read_man

    def test_write_file(self, python_separator, config_parser_mock,
                        separator_comment_dir, separator_code_dir):
        comment_file = os.path.join(
            separator_comment_dir,
            config_parser_mock().get('python-test-files', 'write'))
        code_file = os.path.join(
            separator_code_dir,
            config_parser_mock().get('python-test-files', 'write'))
        comment = ['# this is just a comment']
        code = ['import sys\n', '\n', 'print("foo")']

        python_separator.write_file(comment_file, comment)
        assert os.path.exists(comment_file) is True

        python_separator.write_file(code_file, code)
        assert os.path.exists(code_file) is True

        with open(comment_file) as f:
            assert comment == f.readlines()

        with open(code_file) as f:
            assert code == f.readlines()

    def test_separate(self, python_separator, config_parser_mock,
                      separator_exploit_dir, separator_comment_dir,
                      separator_code_dir):
        exploit_file = config_parser_mock().get(
            'python-test-files', 'sep_succ')
        comments = [
            '# this is a python separate test example # new hash\n',
            '# the code is just a test to separate code and comments\n',
            ' \n',
            '\n',
            '     """\n',
            '    this is a test class\n',
            '    """    # one line comment\n',
            '    \n',
            '\n',
            '       # test\n',
            '    \n',
            '# print argv of sys    # create list # append to list# '
            'pop an element of li\n',
            '//""" multi line\n',
            '\n',
            'comment\n',
            '"""      \\\n',
            '      '
        ]

        code = [
            '\n',
            'import sys\n',
            '\n',
            '\n',
            'class Test(object):\n',
            '\n',
            '\n',
            '    pass\n',
            '\n',
            '\n',
            'for x in range(10):\n',
            '\n',
            '    print(x)\n',
            '\n',
            'print(sys.argv)\n',
            'li = []\n',
            "li.append('foo bar')\n",
            '\n',
            'print(li.pop())\n',
            '\n',
            '\n',
            'select = """ SELECT * FROM foo;"""\n',
            'drop = """\n',
            'DROP TABLE foo;"""\n',
            'insert = \\\n',
            '    """\n',
            '    INSERT INTO foo ("foo" \'bar\') VALUES (\'bar\' "foo");\n',
            '    """\n',
            'no_comment = """\n',
            '## this is a variable\n',
            '# and not a comment\n',
            '"""\n'
        ]

        python_separator.separate(exploit_file)
        comment_file = os.path.join(
            separator_comment_dir,
            config_parser_mock().get('python-test-files', 'sep_succ'))
        code_file = os.path.join(
            separator_code_dir,
            config_parser_mock().get('python-test-files', 'sep_succ'))
        with open(comment_file) as f:
            comments_read = f.readlines()
        assert comments == comments_read

        with open(code_file) as f:
            code_read = f.readlines()
        assert code == code_read

    def test_separate_indent_err(
            self, python_separator, config_parser_mock, separator_comment_dir,
            separator_code_dir, separator_quarantine_dir):
        exploit_file = config_parser_mock().get(
            'python-test-files', 'sep_indent_err')

        python_separator.separate(exploit_file)
        assert python_separator.logger.warn.call_count == 1
        python_separator.logger.warn.assert_called_with(
            'PythonErrorLeaf or PythonErrorNode occurred 1 times for file: '
            'sep_python_indent.py. This file is saved in quarantine dir.')

        comment_file = os.path.join(separator_comment_dir, exploit_file)
        code_file = os.path.join(separator_code_dir, exploit_file)
        assert os.path.exists(comment_file) is False
        assert os.path.exists(code_file) is False
        
        quarantine_comment_file = os.path.join(
            os.path.join(separator_quarantine_dir, 'comments'), exploit_file)
        quarantine_code_file = os.path.join(
            os.path.join(separator_quarantine_dir, 'code'), exploit_file)
        assert os.path.exists(quarantine_comment_file) is True
        assert os.path.exists(quarantine_code_file) is True
        


    def test_separate_general_err(
            self, python_separator, config_parser_mock, separator_comment_dir,
            separator_code_dir):
        exploit_file = config_parser_mock().get(
            'python-test-files', 'sep_succ')
        exception_msg = 'just another exception'
        python_separator.logger.debug.side_effect = Exception(exception_msg)

        with pytest.raises(Exception) as execinfo:
            python_separator.separate(exploit_file)

        assert str(execinfo.value) == exception_msg
        assert python_separator.logger.warn.call_count == 0
