from pymongo import MongoClient
from bson.errors import InvalidStringData

from config.config_parser import get_config_parser


class MongoDBConnection(object):

    def __init__(self, logger, db_name='exploitdb', collection='exploits'):
        """
        Declares some object attributes.
        :param logger: A logger object for this connection class.
        :param db_name (str): Name of the database to use; default is
        "exploitdb".
        :param collection (str): Name of the collection to use; default is
        "exploits".
        """
        self.parser = get_config_parser()
        self.client = MongoClient(self.parser.get('mongodb', 'url'))
        self.collection = self.client[db_name][collection]
        self.logger = logger

    def get_all_exploits(self):
        """
        Retrieves all data of the initialized collection.
        :return: List of retrieved dict objects.
        """
        return list(self.collection.find())

    def insert_exploits(self, data):
        """
        Inserts data into the initialized collection.
        :param data (list): List of dict objects to insert into the collection.
        """
        self.collection.insert_many(data)

    def get_exploits_by_file_extension(self, extension):
        """
        Retrieves all exploits by a given file extension.
        :param extension (str): Extension as string (e.g. py).
        :return: List of retrieved dict objects.
        """
        return self.collection.find(
            {
                'file': {
                    '$regex': '.{}$'.format(extension)
                }
            })

    def get_exploits_by_file_extension_and_id(self, extension, ids):
        """
        Retrieves all exploits by a given file extension and by the given ids.
        :param extension (str): Extension as string (e.g. py).
        :param ids (list): List of ids (int) to filter for.
        :return: List of retrived dict objects.
        """
        return self.collection.find(
            {
                'file': {
                    '$regex': '.{}$'.format(extension)
                },
                'id': {
                    '$in': ids
                }
            })

    def insert_or_update_exploits_by_id(self, ins_up_exploits):
        """
        Inserts exploits or if the exploit already exists (compared by the id)
        it  updates it. If any Exception occurs while insert or update it will
        be logged as an error.
        :param ins_up_exploits (list): List of dict objects to insert or
        update.
        """
        for item in ins_up_exploits:
            try:
                self.collection.update_one(
                    {
                        'id': item['id']
                    },
                    {
                        '$set': item
                    },
                    upsert=True
                )
            except Exception as e:
                self.logger.error(
                    'Unexpected exception {} for filename {}.'.format(
                        e, item['file']), exc_info=True)

    def update_exploits_by_file(self, update_dict):
        """
        Updates exploits which are found by the filename. InvalidStringData
        exceptions are logged as warnings and can occur if a given string
        can't be converted to UTF-8. Any other exception is logged as an error.
        :param update_dict (dict): Dict object of exploit information to
        update.
        """
        for filename, update in update_dict.items():
            try:
                if update:
                    result = self.collection.update_one(
                        {
                            'file': filename
                        },
                        {
                            '$set': update
                        }
                    )
                    if result.matched_count == 0:
                        self.logger.warn(
                            'Exploit with filename {} not found.'.format(
                                filename))
            except InvalidStringData:
                self.logger.warn('InvalidStringData for filename '
                                 '{}.'.format(filename))
            except Exception as e:
                self.logger.error(
                    'Unexpected exception {} for filename {}.'.format(
                        e, filename), exc_info=True)

    def close(self):
        """
        Closes the database connection.
        """
        self.client.close()
