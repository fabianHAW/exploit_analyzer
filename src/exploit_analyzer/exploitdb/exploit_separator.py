"""
TODO: ist ii) einkommentiert, so werden weniger PythonErrorNode und
PythonErrorLeaf erzeugt..mal mit und mal ohne ii) rumprobieren..
ii) einkommentieren damit exploits/hardware/webapps/45002.py funktioniert
aber exploits/hardware/webapps/45351.py geht dann nicht mehr
- ist ii) einkommentiert, werden weniger exploits in quarantaene gestellt o.O.
    - allerdings gibt es immer noch code der nicht geparst werden kann, obwohl
    nicht in quarantaene
"""


import re
import os.path

from abc import ABCMeta, abstractmethod
from os import makedirs
from parso import parse
from parso.python.tree import (
    EndMarker, PythonErrorLeaf, PythonErrorNode, Name, Keyword, Operator)

from exploit_analyzer.config.config_parser import get_config_parser


class Separator(metaclass=ABCMeta):
    @classmethod
    def create_separator(cls, sep_type, logger):
        parser = get_config_parser()
        exploit_dir = parser.get('git', 'local_git')
        comment_dir = parser.get('separator', 'comment_dir')
        code_dir = parser.get('separator', 'code_dir')
        quarantine_dir = parser.get('separator', 'quarantine_dir')

        if sep_type == 'python':
            return PythonSeparator(logger, exploit_dir, comment_dir, code_dir,
                                   quarantine_dir)
        else:
            raise ValueError(
                'No Separator found for type: {}'.format(sep_type))

    def read_file(self, abs_filename):
        """
        abs_filename (str): Absolute path of the file.
        """
        with open(abs_filename) as f:
            exploit = f.read()
        return exploit

    def write_file(self, abs_filename, data):
        """
        abs_filename (str): Absolute path of the file.
        """
        subdir, _ = os.path.split(abs_filename)
        makedirs(subdir, exist_ok=True)
        self.logger.debug('Write {} to dir {}'.format(abs_filename, subdir))
        with open(abs_filename, 'w') as f:
            f.writelines(data)

    @abstractmethod
    def separate(self, abs_filename):
        pass


class PythonSeparator(Separator):
    def __init__(self, logger, exploit_dir, comment_dir, code_dir,
                 quarantine_dir):
        self.logger = logger
        self.exploit_dir = exploit_dir
        self.comment_dir = comment_dir
        self.code_dir = code_dir
        self.quarantine_dir = quarantine_dir
        self.total_error_count = 0

    def _version_check(self, exploit):
        if re.search(r'^#!/.*python3', exploit) is not None:
            module = parse(exploit)
        else:
            module = parse(exploit, version='2.7.12')
        # if re.search(r'^#!/.*python$', exploit) is not None:
        return module

    def _handle_comment(self, child):
        code_w_comment = child.get_code()
        code_no_comment = child.get_code(include_prefix=False)
        comment = code_w_comment[:-len(code_no_comment)]
        idx = code_w_comment.rfind(code_no_comment)
        if (code_no_comment.startswith('\'\'\'') or
                code_no_comment.startswith('"""')) and \
                not isinstance(child.get_previous_leaf(), Operator):
            return code_w_comment, ''
        else:
            sp_char = []
            while idx > -1:
                idx -= 1
                elem = code_w_comment[idx]
                # escape characters and \ (\\) at the end of the line
                if elem in [' ', '\n', '\t', '\r', '\\'] and idx != -1:
                    sp_char.append(elem)
                else:
                    idx = -1
            # use reversed list
            return comment, '{}{}'.format(
                ''.join(sp_char[::-1]), code_no_comment)

    def _walk(self, child, line_num):
        comments = []
        code = []
        error_count = 0
        # ii)
        if line_num != -1 and not isinstance(child, list):
            child_line_num, _ = child.start_pos
            if child_line_num == line_num:
                comments.append(child.get_code())
        if hasattr(child, 'children'):
            return self._walk(child.children, line_num)
        elif isinstance(child, list):
            for next_child in child:
                walked_comments, walked_code, walked_error_count = \
                    self._walk(next_child, line_num)
                comments.extend(walked_comments)
                code.extend(walked_code)
                error_count += walked_error_count
        else:
            return self._check_nodes(child)
        return comments, code, error_count

    def _check_nodes(self, child):
        if isinstance(child, EndMarker):
            return child.get_code(), '', 0
        elif isinstance(child, PythonErrorLeaf) or \
                isinstance(child, PythonErrorNode):
            return '', child.get_code(), 1
        elif isinstance(child, Name):
            # check keyword, check previous leaf, check next leaf
            if isinstance(child.get_previous_leaf(), Keyword) or \
                    isinstance(child.get_previous_leaf(), Operator) or \
                    isinstance(child.get_next_leaf(), Operator):
                comment, code = self._handle_comment(child)
                return comment, code, 0
            elif not child.is_definition():
                return child.get_code(), '', 0
            else:
                comment, code = self._handle_comment(child)
                return comment, code, 0
        else:
            comment, code = self._handle_comment(child)
            return comment, code, 0

    def separate(self, filename):
        # cannot use a set, otherwise the code and comment order isn't right
        comments = []
        code = []
        error_count = 0
        try:
            abs_filename = os.path.join(self.exploit_dir, filename)
            self.logger.debug('Start separating..')
            exploit = self.read_file(abs_filename)
            module = self._version_check(exploit)
            line_num = -1
            for child in module.children:
                # ii)
                if isinstance(child, PythonErrorNode) or  \
                        isinstance(child, PythonErrorLeaf):
                    comments.append(child.get_code())
                    line_num, _ = child.start_pos
                else:
                    walked_comments, walked_code, walked_error_count = \
                        self._walk(child, line_num)
                    comments.extend(walked_comments)
                    code.extend(walked_code)
                    error_count += walked_error_count
                    line_num = -1
        except Exception:
            raise
        finally:
            if error_count > 0:
                self.total_error_count += 1
                self.logger.warn(
                    'PythonErrorLeaf or PythonErrorNode occurred {} times for '
                    'file: {}. This file is saved in quarantine dir.'.format(
                        error_count, filename))
                self.write_file(
                    os.path.join(
                        os.path.join(self.quarantine_dir, 'comments'),
                        filename), comments)
                self.write_file(
                    os.path.join(
                        os.path.join(self.quarantine_dir, 'code'),
                        filename), code)
            else:
                self.write_file(
                    os.path.join(self.comment_dir, filename), comments)
                self.write_file(os.path.join(self.code_dir, filename), code)
