import re
import os.path

from abc import ABCMeta, abstractmethod
from os import makedirs
from parso import parse
from parso.python.tree import (
    EndMarker, PythonErrorLeaf, PythonErrorNode, Name, Keyword, Operator)

from config.config_parser import get_main_config_parser


class Separator():
    __metaclass__ = ABCMeta

    @classmethod
    def create_separator(cls, sep_type, logger):
        """
        Class method to initialize a new separator depending on the programming
        language. Acutal only python is implemented.
        :param sep_type (str): Type of programming language.
        :param logger: A logger object.
        :return: PythonSeparator object if sep_type is python, otherwise raises
        a ValueError.
        :raises: ValueError if the sep_type is not valid.
        """
        parser = get_main_config_parser()
        exploit_dir = parser.get('git', 'local_git')
        comment_dir = parser.get('separator', 'comment_dir')
        code_dir = parser.get('separator', 'code_dir')
        quarantine_dir = parser.get('separator', 'quarantine_dir')

        if sep_type == 'python':
            return PythonSeparator(logger, exploit_dir, comment_dir, code_dir,
                                   quarantine_dir)
        else:
            raise ValueError(
                'No Separator found for type: {}'.format(sep_type))

    def read_file(self, abs_filename):
        """
        Reads a file by the given absolute filepath and returns it as string.
        :param abs_filename (str): Absolute path of the file.
        :return: Content of the file as string.
        """
        with open(abs_filename) as f:
            exploit = f.read()
        return exploit

    def write_file(self, abs_filename, data):
        """
        Writes the data to the given absolute filepath. If the dir to save the
        file to does not exist, it will be created. If a TypeError is raised,
        it tries to encode the given data to UTF-8.
        :param abs_filename (str): Absolute path of the file.
        :param data: List of strings to write to file.
        """
        subdir, _ = os.path.split(abs_filename)
        if not os.path.exists(subdir):
            makedirs(subdir)
        with open(abs_filename, 'w') as f:
            try:
                f.writelines(data)
            except TypeError:
                f.writelines([d.encode('utf-8') for d in data])

    @abstractmethod
    def separate(self, abs_filename):
        """
        Abstract method to separate a file.
        """
        pass


class PythonSeparator(Separator):
    def __init__(self, logger, exploit_dir, comment_dir, code_dir,
                 quarantine_dir):
        """
        Declares some object attributes.
        :param logger: A logger object.
        :param exploit_dir (str): Absolute path to the exploit dir.
        :param comment_dir (str): Absolute path to the comment dir.
        :param code_dir (str): Absolute path to the code dir.
        :param quarantine_dir (str): Absolute path to the quarantine dir.
        """
        self.logger = logger
        self.exploit_dir = exploit_dir
        self.comment_dir = comment_dir
        self.code_dir = code_dir
        self.quarantine_dir = quarantine_dir
        self.total_error_count = 0

    def _version_check(self, exploit):
        """
        Checks the version of a given exploit by trying to match the python3
        shebang. If python3 shebang is found, it initialize a parser object
        with version 3.5; otherwise with the version this module is executed.
        :param exploit (str): An exploit to check for python shebang.
        :return: A parso.python.tree.Module object.
        """
        if re.search(r'^#!/.*python3', exploit) is not None:
            module = parse(exploit, version='3.5')
        else:
            # version is current python version which is used to execute
            module = parse(exploit)
        return module

    def _handle_comment(self, child):
        """
        Tries to separate comments and code by a given tree node. If a
        UnicodeEncodeError occurs while joining code without comment and
        escape characters, it tries to encode the code without comment as
        UTF-8.
        :param child: Tree node if it is not an Endmarker, PythonErrorLeaf or
        PythonErrorNode.
        :return: 2-tuple:
            1. element: separated comment as string.
            2. element: separated code as string.
        """
        code_w_comment = child.get_code()
        # with include_prefix=False it keeps the prefix (whitespaces and
        # comments) of the code.
        code_no_comment = child.get_code(include_prefix=False)
        comment = code_w_comment[:-len(code_no_comment)]
        idx = code_w_comment.rfind(code_no_comment)
        if (code_no_comment.startswith('\'\'\'') or
                code_no_comment.startswith('"""')) and \
                not isinstance(child.get_previous_leaf(), Operator):
            # handle multi line comments
            return code_w_comment, ''
        else:
            sp_char = []
            while idx > -1:
                idx -= 1
                elem = code_w_comment[idx]
                # escape characters and \ (\\) at the end of the line
                if elem in [' ', '\n', '\t', '\r', '\\'] and idx != -1:
                    sp_char.append(elem)
                else:
                    idx = -1
            # use reversed list [::-1]
            try:
                code = '{}{}'.format(''.join(sp_char[::-1]), code_no_comment)
            except UnicodeEncodeError:
                code = '{}{}'.format(''.join(sp_char[::-1]),
                                     code_no_comment.encode('utf-8'))
            return comment, code

    def _walk(self, child, line_num):
        """
        Walks via the parso tree nodes as a recursive method. If the child has
        no children attribute nor is a list, it calls self._check_nodes and
        return this result.
        :param child: A parso tree node object.
        :param line_num (int): The line number where to find the given child
        in the exploit.
        :return: A 3-tuple:
            1. element: A list of separated comments as string.
            2. element: A list of separated code as string.
            3. element: Number of errors (PythonErrorNode or PythonErrorLeaf)
            which are occurred.
        """
        comments = []
        code = []
        error_count = 0
        if line_num != -1 and not isinstance(child, list):
            child_line_num, _ = child.start_pos
            if child_line_num == line_num:
                comments.append(child.get_code())
        if hasattr(child, 'children'):
            return self._walk(child.children, line_num)
        elif isinstance(child, list):
            for next_child in child:
                walked_comments, walked_code, walked_error_count = \
                    self._walk(next_child, line_num)
                comments.extend(walked_comments)
                code.extend(walked_code)
                error_count += walked_error_count
        else:
            return self._check_nodes(child)
        return comments, code, error_count

    def _check_nodes(self, child):
        """
        Check the tree nodes instances and decide what to do. If child is an
        Endmaker or PythonErrorNode or PythonErrorLeaf it returns directly;
        otherwise it call self._handle_comment().
        :param child: A parso tree node object.
        :return: A 3-tuple:
            1. element: Separated comment as string.
            2. element: Separated code as string.
            3. element: Number of errors (PythonErrorNode or PythonErrorLeaf)
            which are occurred.
        """
        if isinstance(child, EndMarker):
            return child.get_code(), '', 0
        elif isinstance(child, PythonErrorLeaf) or \
                isinstance(child, PythonErrorNode):
            return '', child.get_code(), 1
        elif isinstance(child, Name):
            # check keyword, check previous leaf, check next leaf
            if isinstance(child.get_previous_leaf(), Keyword) or \
                    isinstance(child.get_previous_leaf(), Operator) or \
                    isinstance(child.get_next_leaf(), Operator):
                comment, code = self._handle_comment(child)
                return comment, code, 0
            elif not child.is_definition():
                return child.get_code(), '', 0
            else:
                comment, code = self._handle_comment(child)
                return comment, code, 0
        else:
            comment, code = self._handle_comment(child)
            return comment, code, 0

    def separate(self, filename):
        """
        Concrete implementation of separator method to separate an exploit to
        comments and code. It walks via the tree nodes and handle the concrete
        line in the exploit. It logs a warning, if there occurred more than one
        PythonErrorNode or PythonErrorLeaf. Lastly it writes the separated
        comments and code to the comment respectively code dir.
        :param filename (str): The relative filepath of the exploit
        :raises: Exception if something went wrong it will be re-raised.
        """
        comments = []
        code = []
        error_count = 0
        try:
            abs_filename = os.path.join(self.exploit_dir, filename)
            self.logger.debug('Start separating..')
            exploit = self.read_file(abs_filename)
            module = self._version_check(exploit)
            line_num = -1
            for child in module.children:
                if isinstance(child, PythonErrorNode) or  \
                        isinstance(child, PythonErrorLeaf):
                    comments.append(child.get_code())
                    line_num, _ = child.start_pos
                else:
                    walked_comments, walked_code, walked_error_count = \
                        self._walk(child, line_num)
                    comments.extend(walked_comments)
                    code.extend(walked_code)
                    error_count += walked_error_count
                    line_num = -1
        except Exception:
            raise
        finally:
            if error_count > 0:
                self.total_error_count += 1
                self.logger.warn(
                    'PythonErrorLeaf or PythonErrorNode occurred {} times for '
                    'file: {}. This file is saved in quarantine dir.'.format(
                        error_count, filename))
                self.write_file(
                    os.path.join(
                        os.path.join(self.quarantine_dir, 'comments'),
                        filename), comments)
                self.write_file(
                    os.path.join(
                        os.path.join(self.quarantine_dir, 'code'),
                        filename), code)
            else:
                self.write_file(
                    os.path.join(self.comment_dir, filename), comments)
                self.write_file(os.path.join(self.code_dir, filename), code)
