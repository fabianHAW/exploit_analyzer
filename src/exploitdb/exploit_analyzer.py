import os.path
import re
import ast

from abc import ABCMeta, abstractmethod

from config.config_parser import get_main_config_parser


class ExploitAnalyzer():
    __metaclass__ = ABCMeta

    def __init__(self):
        """
        Declares some object attributes.
        """
        self.parser = get_main_config_parser()
        self.comment_dir = self.parser.get('separator', 'comment_dir')
        self.code_dir = self.parser.get('separator', 'code_dir')
        self.result = {}
        self.result_counter = {}
        self.result_counter['ip'] = 0
        self.result_counter['cve'] = 0
        self.result_counter['additional-urls'] = 0
        self.result_counter['additional-emails'] = 0

    def read_file(self, abs_filename):
        """
        Reads a file by the given absolute filepath and returns it as string.
        :param abs_filename (str): Absolute path of the file.
        :return: Content of the file as string.
        """
        with open(abs_filename) as f:
            exploit = f.read()
        return exploit

    def _general_analyze(self, exploit, filename):
        """
        Makes a general analyze of the given exploit. Currently it searchs
        for cve, ip addresses, urls and emails by regular expressions.
        :param exploit (str): Exploit as string.
        :param filename (str): The relative filepath of the exploit.
        """
        cve_pattern = r'cve-\d{4}-\d{4,7}'
        # important: in case of a line-break in this pattern string, we need to
        # add a double backslash at the end to keep \b in the string
        ip_addr_pattern = \
            r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)' \
            '{3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b'
        url_pattern = r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\(\),]|' \
            '(?:%[0-9a-fA-F][0-9a-fA-F]))+'
        email_pattern = r'\b[\w!#$%&\'*+/=?`{|}~^-]+(?:\.[\w!#$%&\'*+/=?`' \
            '{|}~^-]+)*@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}\\b'
        cves = list(
            {x.group(0) for x in re.finditer(cve_pattern, exploit.lower())})
        ips = list(
            {x.group(0) for x in re.finditer(
                ip_addr_pattern, exploit.lower())})
        urls = list(
            {x.group(0) for x in re.finditer(
                url_pattern, exploit.lower())})
        emails = list(
            {x.group(0) for x in re.finditer(
                email_pattern, exploit.lower(), re.I)})
        if cves:
            # cves have to be upper for MISP
            self.result[filename]['cve'] = [cve.upper() for cve in cves]
        if ips:
            self.result[filename]['ip'] = ips
        if urls:
            self.result[filename]['additional-urls'] = urls
        if emails:
            self.result[filename]['additional-emails'] = emails

    def generate_stats(self):
        """
        Counts the results of every exploit by the tags.
        """
        for item in self.result.values():
            for tag, value in item.items():
                if tag in self.result_counter:
                    self.result_counter[tag] += len(value)
                else:
                    self.result_counter[tag] = 1

    @abstractmethod
    def analyze(self, exploit, filename, exploit_id):
        """
        Abstract method which does the general analyzes of the given exploit.
        Every class which inherit from this class have to implement it.
        :param exploit (str): Exploit as string.
        :param filename (str): The relative filepath of the exploit.
        """
        self.result.setdefault(filename.encode('utf-8'), {})
        self.result[filename]['id'] = exploit_id
        self._general_analyze(exploit, filename)


class CommentAnalyzer(ExploitAnalyzer):
    def __init__(self):
        """
        Declares some object attributes.
        """
        super(CommentAnalyzer, self).__init__()
        self.comment_tags = self.parser.get(
            'analyzer', 'comment_tags').split(',')
        # need to encode every tag, otherwise the tag matching in the exploits
        # could fail with an UnicodeDecodeError
        self.comment_tags = [tag.encode('utf-8') for tag in self.comment_tags]
        self.comment_group_tags = self.parser.get(
            'analyzer', 'comment_group_tags').split(',')
        self.comment_group_tags = [
            tag.encode('utf-8') for tag in self.comment_group_tags]
        self.result_counter.update(
            dict.fromkeys(
                [tag.replace(' ', '-') for tag in self.comment_tags], 0))
        self.result_counter['group'] = 0
        # drop e-mail from stats, because it will be merged with email
        self.result_counter.pop('e-mail')

    def _merge_similar_tags(self, filename):
        """
        Merges similar tags in the results. For now it merges the results from
        e-mail tag with email tag.
        :param filename (str): The relative filepath of the exploit.
        """
        if self.result[filename].get('e-mail', []):
            if not self.result[filename].get('email', []):
                self.result[filename]['email'] = []
            self.result[filename]['email'].extend(
                self.result[filename].get('e-mail', []))
            del self.result[filename]['e-mail']

    def _result_check(self, result):
        """
        Checks the content of the found result and if it does make sense to add
        it to the result.
        :param result (str): A result to check.
        :return: Returns an empty string if result is "n/a", "na", "[]" or if
        it contains only one type of char, e.g. "#######". Otherwise it returns
        the result back.
        """
        if result in ['n/a', 'na', '[]']:
            return ''
        # check if result contains only one type of char
        elif not result[0].isdigit() and all(c == result[0] for c in result):
            return ''
        else:
            return result

    def _hash_handling(self, result):
        """
        Removes all hashs at the beginning or ending of a result.
        :param result (str): A result to handle.
        :return: The handled result without any hash at the beginning or
        ending.
        """
        hash_count = 0
        if result.startswith('#'):
            for c in result:
                if c == '#':
                    hash_count += 1
                else:
                    result = result[hash_count:].strip()
                    break
        hash_count = 0
        if result.endswith('#'):
            # reverse string
            for c in result[::-1]:
                if c == '#':
                    hash_count += 1
                else:
                    result = result[:-hash_count].strip()
                    break
        return result

    def analyze(self, filename, exploit_id):
        """
        Concrete implementation of analyze. It calls analyze from superclass
        to make a general analyze. Afterwards it tries to find the initialized
        tags in the comments of an exploit.
        :param filename (str): The relative filepath of the exploit.
        """
        abs_filename = os.path.join(self.comment_dir, filename)
        exploit = self.read_file(abs_filename).lower()
        super(CommentAnalyzer, self).analyze(exploit, filename, exploit_id)
        for tag in self.comment_tags:
            results = set()
            # append colon to tag
            tag_mods = ['{}:'.format(tag), '{} :'.format(tag)]
            for tag_mod in tag_mods:
                idx_list = [m.start() for m in re.finditer(tag_mod, exploit)]
                for idx in idx_list:
                    tag_len_idx = len(tag_mod) + idx
                    exploit_no_tag = exploit[tag_len_idx:].lstrip()
                    idx_nl = exploit_no_tag.find('\n')
                    result = exploit_no_tag[:idx_nl].strip()
                    result = self._result_check(result)
                    result = self._hash_handling(result)
                    if result:
                        results.add(result)
            if results:
                save_tag = tag.replace(' ', '-')
                self.result[filename][save_tag] = list(results)

        for group_tag in self.comment_group_tags:
            if group_tag in exploit:
                if self.result[filename].get('group', []):
                    self.result[filename]['group'].append(group_tag)
                else:
                    self.result[filename]['group'] = [group_tag]

        self._merge_similar_tags(filename)


class CodeAnalyzer(ExploitAnalyzer):
    def __init__(self):
        """
        Declares some object attributes.
        """
        super(CodeAnalyzer, self).__init__()
        self.code_tags = self.parser.get(
            'analyzer', 'code_tags').split(',')
        # need to encode every tag, otherwise the tag matching in the exploits
        # could fail with an UnicodeDecodeError
        self.code_tags = [tag.encode('utf-8') for tag in self.code_tags]
        self.result_counter.update(dict.fromkeys(self.code_tags, 0))

    def _assign_node(self, node, filename):
        """
        Looks for specific strings in an assignment. It uses a helper function
        to look for other strings, see self._assign_node_helper() for more
        information. Actually it looks for port.
        :param node (_ast.Assign): Assign object of ast.
        :param filename (str): The relative filepath of the exploit.
        """
        for target in node.targets:
            if hasattr(target, 'id'):
                target_id = target.id.lower()
                self._assign_node_helper(node, filename, target_id)
                # check for port in assignments and if the right side of the
                # assignment is string or number
                if 'port' in target_id:
                    if hasattr(node.value, 's'):
                        node_val = node.value.s
                    elif hasattr(node.value, 'n'):
                        node_val = str(node.value.n)
                    else:
                        node_val = ''
                    # prevent adding port which is not a number
                    if node_val.isdigit():
                        tag = 'analyzed-port' \
                            if target_id == 'port' else target_id
                        self._result_add(filename, tag, node_val)

    def _assign_node_helper(self, node, filename, target_id):
        """
        A helper function which is used from self._assign_node to look for
        specific strings in an assignment. Actually it looks for user-agent,
        payload and content-type.
        :param node (_ast.Assign): Assign object of ast.
        :param filename (str): The relative filepath of the exploit.
        :param target_id (str): The string to analyze.
        """
        if hasattr(node.value, 's'):
            # check for user agent in assignments
            if target_id in ['useragent', 'user-agent', 'user_agent']:
                self._result_add(filename, 'user-agent', node.value.s)
            if 'payload' in target_id:
                if node.value.s:
                    self._result_add(filename, 'payload', node.value.s)
            if target_id in ['content_type', 'content-type']:
                c_type = node.value.s.split(';')[0].strip()
                self._result_add(filename, 'content-type', c_type)

    def _augassign_node(self, node, filename):
        """
        Looks for specific strings in an aug-assignment. An aug-assignment is
        e.g. "msg += 'something'". Actually it looks for content-type.
        :param node (_ast.AugAssign): AugAssign object of ast.
        :param filename (str): The relative filepath of the exploit.
        """
        node_val = node.value
        if hasattr(node_val, 's') and 'content-type' in node_val.s.lower():
            c_type = node_val.s.lower().split('content-type:')[1].strip()
            # need to split after semicolon, because some content-type strings
            # may contain charset, boundary or any other mail header tag
            c_type = c_type.split(';')[0].strip()
            self._result_add(filename, 'content-type', c_type)

    def _expr_node(self, node, filename):
        """
        Looks for specific strings in an expression. Actually it looks for
        user-agent, content-type and help as a keyword argument e.g. in an
        ArgumentParser object.
        :param node (_ast.Expr): Expr object of ast.
        :param filename (str): The relative filepath of the exploit.
        """
        if hasattr(node.value, 'args'):
            for i, arg in enumerate(node.value.args):
                # user-agent and content-type are the only possible solutions
                # for an expression
                if hasattr(arg, 's'):
                    # if arg has a s-attribute we are sure that args[i+1]
                    # exists
                    if arg.s.lower() == 'user-agent' \
                            and hasattr(node.value.args[i + 1], 's'):
                        self._result_add(
                            filename, 'user-agent', node.value.args[i + 1].s)
                    if arg.s.lower() == 'content-type' \
                            and hasattr(node.value.args[i + 1], 's'):
                        c_type = node.value.args[i + 1].s.split(';')[0].strip()
                        self._result_add(filename, 'content-type', c_type)
        if hasattr(node.value, 'keywords'):
            for keyword in node.value.keywords:
                if 'help' in keyword.arg and hasattr(keyword.value, 's'):
                    if len(node.value.args) == 0:
                        param = 'no-param'
                    else:
                        param = node.value.args[0].s
                    self._result_add(
                        filename, 'help-parser-arg',
                        '{}: {}'.format(
                            param, keyword.value.s))

    def _dict_node(self, node, filename):
        """
        Looks for specific strings in a dict. Actually it looks for user-agent
        and content-type.
        :param node (_ast.Dict): Dict object of ast.
        :param filename (str): The relative filepath of the exploit.
        """
        for i, key in enumerate(node.keys):
            if hasattr(key, 's') and \
                    hasattr(node.values[i], 's') and \
                    key.s.lower() in ['user-agent', 'user agent']:
                self._result_add(filename, 'user-agent', node.values[i].s)
            if hasattr(key, 's') and \
                    hasattr(node.values[i], 's') and \
                    key.s.lower() == 'content-type':
                c_type = node.values[i].s.split(';')[0].strip()
                self._result_add(filename, 'content-type', c_type)

    def _result_add(self, filename, tag, value):
        """
        Adds a new value to a given tag to the result dictionary.
        :param filename (str): The relative filepath of the exploit.
        :param tag (str): A tag name where to add the value in the result dict.
        :param value(str): The value to add to the result under the given tag.
        """
        tag_result = set(self.result[filename].get(tag, []))
        if tag_result:
            tag_result.add(value)
            self.result[filename][tag] = list(tag_result)
        else:
            self.result[filename][tag] = [value]

    def analyze(self, filename, exploit_id):
        """
        Concrete implementation of analyze. It calls analyze from superclass
        to make a general analyze. Afterwards it tries to find some specific
        strings in the ast of the code of an exploit.
        :param filename (str): The relative filepath of the exploit.
        """
        abs_filename = os.path.join(self.code_dir, filename)
        exploit = self.read_file(abs_filename)
        super(CodeAnalyzer, self).analyze(exploit, filename, exploit_id)
        tree = ast.parse(exploit)
        for node in ast.walk(tree):
            if isinstance(node, ast.ImportFrom):
                for imp in node.names:
                    value = '{} ({})'.format(imp.name, node.module)
                    self._result_add(filename, 'py-imports', value)
            elif isinstance(node, ast.Import):
                for imp in node.names:
                    self._result_add(filename, 'py-imports', imp.name)
            elif isinstance(node, ast.Assign):
                self._assign_node(node, filename)
            elif isinstance(node, ast.Dict):
                self._dict_node(node, filename)
            elif isinstance(node, ast.Expr):
                self._expr_node(node, filename)
            elif isinstance(node, ast.AugAssign):
                self._augassign_node(node, filename)
