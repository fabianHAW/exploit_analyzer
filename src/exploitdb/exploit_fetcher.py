import os.path
import pandas as pd
import json

from git import Repo
from os import makedirs


def _create_dirs(parser):
    """
    Create dirs for separator and visualization component if they not exist.
    :param parser: ConfigParser object.
    """
    comment_dir = parser.get('separator', 'comment_dir')
    code_dir = parser.get('separator', 'code_dir')
    quarantine_dir = parser.get('separator', 'quarantine_dir')
    asset_dir = parser.get('visualization', 'plot_dir')
    if not os.path.exists(comment_dir):
        makedirs(comment_dir)
    if not os.path.exists(code_dir):
        makedirs(code_dir)
    if not os.path.exists(quarantine_dir):
        makedirs(quarantine_dir)
    if not os.path.exists(asset_dir):
        makedirs(asset_dir)


def fetch_exploits(parser, db):
    """
    Fetches the github repository of ExploitDB and load the input of the csv
    file into the database. If the repository already exists it only fetches
    new exploits.
    :param parser: ConfigParser object.
    :param db: MongoDBConnection object.
    :return: None if the repository is fetched the first time, otherwise
    a list of exploit ids which are new or modified.
    """
    LOCAL_GIT = parser.get('git', 'local_git')
    if not os.path.exists(LOCAL_GIT):
        REMOTE_GIT = parser.get('git', 'remote_git')
        EXPLOITS_CSV_FILE = os.path.join(
            LOCAL_GIT, parser.get('git', 'exploits_csv_file'))
        Repo.clone_from(REMOTE_GIT, LOCAL_GIT)
        data = pd.read_csv(EXPLOITS_CSV_FILE)
        data_json = json.loads(data.to_json(orient='records'))
        db.insert_exploits(data_json)
        _create_dirs(parser)
        return None
    else:
        repo = Repo(LOCAL_GIT)
        # only fetch changes in repo. FetchInfo objects with pull does not
        # contain any Diff object. a pull to save changes in local is made at
        # the end of this method
        fetch_infos = repo.remotes.origin.fetch()
        if fetch_infos:
            ins_up_exploits = []
            ids = []
            # get the newest commit. in this commit are all past commits since
            # last fetch
            fetch = fetch_infos[0]
            for fetch_info in fetch_infos[1:]:
                if fetch.commit.committed_datetime < \
                        fetch_info.commit.committed_datetime:
                    fetch = fetch_info
            csv_diff = [diff for diff in fetch.commit.diff()
                        if parser.get(
                            'git', 'exploits_csv_file') == diff.a_rawpath]
            for diff in csv_diff:
                a_blob = diff.a_blob.data_stream.read().split('\n')
                b_blob = diff.b_blob.data_stream.read().split('\n')
                blob_diffs = set(a_blob) - set(b_blob)
                for blob_diff in blob_diffs:
                    # split guarantees to keep the order:
                    # https://hg.python.org/cpython/file/tip/Lib/test/string_tests.py#l359
                    items = blob_diff.split(',')
                    exploit_id = int(items[0])
                    # guarantee right datatype for port
                    if items[7]:
                        port = int(items[7])
                    else:
                        port = None
                    ins_up_exploits.append({
                        'id': exploit_id,
                        'file': items[1],
                        'description': items[2],
                        'date': items[3],
                        'author': items[4],
                        'type': items[5],
                        'platform': items[6],
                        'port': port
                    })
                    ids.append(exploit_id)
            db.insert_or_update_exploits_by_id(ins_up_exploits)
            # now update local repo with pull
            repo.remotes.origin.pull()
        return ids
