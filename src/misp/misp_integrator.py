import os.path

from pymisp import PyMISP
from pymisp.tools import GenericObjectGenerator

from config.config_parser import get_main_config_parser, get_misp_config_parser


class MISPIntegrator(object):
    def __init__(self, logger, db):
        """
        Declares some object attributes.
        :param logger: A logger object.
        :param db: A MongoDBConnection object.
        """
        self.parser = get_main_config_parser()
        self.misp_parser = get_misp_config_parser()
        self.misp = PyMISP(
            self.parser.get('misp', 'url'),
            self.parser.get('misp', 'key'),
            ssl=bool(self.parser.get('misp', 'ssl')),
            out_type=self.parser.get('misp', 'out_type'),
            debug=bool(self.parser.get('misp', 'debug')))
        self.distribution = self.parser.get('misp', 'distribution')
        self.local_git = self.parser.get('git', 'local_git')
        self.remote_git = self.parser.get(
            'git', 'remote_git').rsplit('.', 1)[0]
        self.attributes = dict(self.misp_parser.values()[1].items())
        self.logger = logger
        self.db = db
        tag_name, tag_colour = self.parser.get('misp', 'tag').split(',')
        all_tags = self._set_tag_id(tag_name, tag_colour)
        taxonomies = self.parser.get('misp', 'taxonomies').split(',')
        self._set_taxonomy_tag_ids(taxonomies, all_tags)

    def _set_tag_id(self, tag_name, tag_colour):
        """
        Determines the ID to a given tag. If the tag is not present in MISP
        it will be created otherwise.
        :param tag_name (str): Name of the tag to create if necessary.
        :param tag_colour (str): A HTML colour code for the tag to create.
        :return: List of all tags in MISP.
        """
        all_tags = self.misp.get_tags_list()
        exploit_tag = [tag for tag in all_tags if tag['name'] == tag_name]
        if exploit_tag:
            self.tag_ids = [exploit_tag[0]['id']]
        else:
            new_tag = self.misp.new_tag(name=tag_name, colour=tag_colour)
            self.tag_ids = [new_tag['Tag']['id']]
        return all_tags

    def _set_taxonomy_tag_ids(self, taxonomies, all_tags):
        """
        If the given taxonomies are not enabled yet, it will be enabled as well
        as the specific tag. The IDs of the taxonomy tags are added to a list.
        If a tag or taxonomy is not found, it will be logged.
        :param taxonomies (list): A list of taxonomies as strings.
        :param all_tags (list): List of all tags in MISP as strings.
        """
        # TODO: it seems that get_taxonomies_list() does not fetch
        # all existing taxonomies:
        # https://github.com/MISP/PyMISP/issues/342
        all_taxonomies = self.misp.get_taxonomies_list()['response']
        for taxonomy in taxonomies:
            namespace, _ = taxonomy.split(':')
            tax = [tax for tax in all_taxonomies
                   if namespace == tax['Taxonomy']['namespace']]
            if tax:
                tax = tax[0]['Taxonomy']
                if not tax['enabled']:
                    # TODO: it seems that it is not possible to enable a
                    # specific tag of a taxonomy, if it is not yet enabled:
                    # https://github.com/MISP/PyMISP/issues/343
                    # until this is not fixed, all tags of the taxonomy must
                    # be enabled. if it is fixed, remove the line with
                    # enable_taxonomy_tags() and uncomment the line with
                    # enable_tag() below
                    self.misp.enable_taxonomy(tax['id'])
                    self.misp.enable_taxonomy_tags(tax['id'])
                tag = [tag for tag in all_tags if tag['name'] == taxonomy]
                if tag:
                    tag_id = tag[0]['id']
                    # self.misp.enable_tag(tag_id)
                    self.tag_ids.append(tag_id)
                else:
                    self.logger.warn(
                        'Could not find tag: {}.'.format(taxonomy))
            else:
                self.logger.warn(
                    'Could not find taxonomy: {}.'.format(taxonomy))

    def _create_event(self, date, description):
        """
        Creates a new event and tag it with the tag id of the config file.
        "Threat Level" has not to be defined (:= no risk), because it is only
        a POC analysis.
        :param date (str): The date when the exploit was created.
        :param description (str): Description of the new event.
        :return: UUID of created event as string.
        """
        uuid = self.misp.new_event(
            date=date,
            info=description,
            distribution=self.distribution)['Event']['uuid']
        for tag_id in self.tag_ids:
            response = self.misp.tag(uuid, tag_id)
            if 'successfully attached to' not in response['message']:
                self.logger.warn(
                    'Could not tag event {}: {}'.format(
                        uuid, response))
        return uuid

    def _add_attributes_to_event(self, uuid, misp_type, values, category,
                                 new_event=True):
        """
        Adds attributes to an event if it is new, otherwise it searches for
        an attribute which has a given value. If not so, a new attribute will
        be created for that event.
        :param uuid (str): The uuid of the event.
        :param misp_type (str): Type of an attribute.
        :param values (list): List of values of the attribute as string.
        :param category (str): Category of an attribute.
        :param new_event (boolean): If the event was added before; default is
        True.
        """
        for val in values:
            if new_event:
                self.misp.add_named_attribute(
                    uuid, misp_type, val, category=category)
            else:
                # if we search for all values in the list, we do not know
                # which attribute we need to add.
                response = self.misp.search(
                    uuid=uuid, type_attribute=misp_type, category=category,
                    values=[val], controller='attributes')['response']
                if not response['Attribute']:
                    self.misp.add_named_attribute(
                        uuid, misp_type, val, category=category)

    def _add_exploit_poc_template(self, uuid, exploit):
        """
        Adds a new exploit-poc object template to a given event.
        :param uuid (str): The uuid of the event.
        :param exploit (dict): Dictionary of an exploit. It needs the following
        keys: 'file', 'author' and 'description'.
        """
        gen_obj = GenericObjectGenerator('exploit-poc')
        attributes = []
        exploit_file = exploit['file']
        with open(os.path.join(self.local_git, exploit_file)) as f:
            poc = f.read()
        attributes.append({
            'poc': poc,
            'references': '{}/tree/master/{}'.format(
                self.remote_git, exploit_file),
            'author': exploit['author'],
            'description': exploit['description']
        })
        gen_obj.generate_attributes(attributes)
        self.misp.add_object(uuid, gen_obj.template_uuid, gen_obj)

    def integrate(self, exploits):
        """
        It integrates the exploits as new events to MISP. If an unexcepted
        exception occurs it will be logged.
        :param exploits (list): List of exploit dictionaries.
        """
        for exploit in exploits:
            try:
                # if this exploit alreadey exist, we do not need to add it
                # again
                if 'misp-uuid' not in exploit:
                    # encode uuid, otherwise the event is not found
                    uuid = self._create_event(
                        exploit['date'], exploit['description']).encode(
                            'utf-8')
                    self.db.insert_or_update_exploits_by_id([
                        {
                            'id': exploit['id'],
                            'misp-uuid': uuid
                        }
                    ])
                    event = None
                else:
                    uuid = exploit['misp-uuid']
                    event = self.misp.get_event(uuid)
                for tag, value in exploit.items():
                    category, misp_type = self.attributes.get(
                        tag, ',').split(',')
                    if not value or tag not in exploit \
                            or (not category and not misp_type):
                        continue
                    # put value to a list, so that we do not need to differ if
                    # it is a list or not.
                    if not isinstance(value, list):
                        value = [value]
                    if event is None:
                        self._add_attributes_to_event(
                            uuid, misp_type, value, category)
                    else:
                        self._add_attributes_to_event(
                            uuid, misp_type, value, category, new_event=False)
                # only add poc if event is new
                if event is None:
                    self._add_exploit_poc_template(uuid, exploit)
            except Exception:
                self.logger.warn(
                    'Unexpected exception while MISP integration occurred',
                    exc_info=True)
